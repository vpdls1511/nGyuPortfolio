{"ast":null,"code":"import _defineProperty from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/workspace/pp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/workspace/pp/src/Slider/index.jsx\";\nimport React from \"react\";\nimport classNames from \"classnames\";\nimport \"./style.css\";\n\nvar Slider =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Slider, _React$Component);\n\n  function Slider(props) {\n    var _this;\n\n    _classCallCheck(this, Slider);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Slider).call(this, props));\n    _this.state = {\n      animating: false,\n      position: Slider.CENTER,\n      animatePrepare: false\n    };\n    _this.startAnimation = _this.startAnimation.bind(_assertThisInitialized(_this));\n    _this.postPrepareAnimation = _this.postPrepareAnimation.bind(_assertThisInitialized(_this));\n    _this.onTransitionEnd = _this.onTransitionEnd.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Slider, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.startAnimation(this.props.position);\n\n      if (this.node) {\n        this.node.addEventListener(\"transitionend\", this.onTransitionEnd);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.node) {\n        this.node.removeEventListener(\"transitionend\", this.onTransitionEnd);\n      }\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      if (newProps.position !== this.props.position) {\n        this.startAnimation(newProps.position, newProps.animationCallback);\n      }\n    }\n  }, {\n    key: \"startAnimation\",\n    value: function startAnimation(position, animationCallback) {\n      var noAnimate = position === Slider.CENTER;\n      var animatingOut = [Slider.TO_LEFT, Slider.TO_RIGHT].includes(position);\n      var currentlyIn = [Slider.CENTER, Slider.FROM_LEFT, Slider.FROM_RIGHT].includes(this.state.position);\n\n      if (noAnimate || currentlyIn && animatingOut) {\n        // in these cases we don't need to prepare our animation at all, we can just\n        // run straight into it\n        this._animationCallback = animationCallback;\n        return this.setState({\n          animatePrepare: false,\n          position: position\n        });\n      }\n\n      this._animationCallback = this.postPrepareAnimation; // in case the transition fails, we also post-prepare after some ms (whichever\n      // runs first should cancel the other)\n\n      this._postPrepareTimeout = setTimeout(this.postPrepareAnimation, 500);\n      this.setState({\n        animating: true,\n        animatePrepare: true,\n        position: position\n      });\n    }\n  }, {\n    key: \"postPrepareAnimation\",\n    value: function postPrepareAnimation() {\n      var _this2 = this;\n\n      clearTimeout(this._postPrepareTimeout);\n      this._animationCallback = null;\n      this.setState({\n        animatePrepare: false\n      }, function () {\n        return _this2._animationCallback = _this2.props.animationCallback;\n      });\n    }\n  }, {\n    key: \"onTransitionEnd\",\n    value: function onTransitionEnd(e) {\n      // the Slider transitions the `transform` property. Any other transitions\n      // that occur on the element we can just ignore.\n      if (e.propertyName !== \"transform\") return;\n      var callback = this._animationCallback;\n      delete this._animationCallback; // an animation callback is another animation, so we only set `animating` to\n      // `false` when we finish the follow-up animation\n\n      if (callback) setTimeout(callback, 0);else this.setState({\n        animating: false\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this,\n          _classNames;\n\n      return React.createElement(\"div\", {\n        ref: function ref(node) {\n          return _this3.node = node;\n        },\n        className: classNames(\"animatable\", (_classNames = {}, _defineProperty(_classNames, \"to\", [Slider.TO_LEFT, Slider.TO_RIGHT].includes(this.state.position)), _defineProperty(_classNames, \"from\", [Slider.FROM_LEFT, Slider.FROM_RIGHT].includes(this.state.position)), _defineProperty(_classNames, \"right\", [Slider.TO_RIGHT, Slider.FROM_RIGHT].includes(this.state.position)), _defineProperty(_classNames, \"left\", [Slider.TO_LEFT, Slider.FROM_LEFT].includes(this.state.position)), _defineProperty(_classNames, \"prepare\", this.state.animatePrepare), _classNames)),\n        \"data-qa-loading\": Boolean(this.props[\"data-qa-loading\"] || this.state.animating),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 95\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: this.props.className,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 116\n        },\n        __self: this\n      }, this.props.children));\n    }\n  }]);\n\n  return Slider;\n}(React.Component);\n\nexport { Slider as default };\nSlider.CENTER = \"CENTER\";\nSlider.TO_LEFT = \"TO_LEFT\";\nSlider.TO_RIGHT = \"TO_RIGHT\";\nSlider.FROM_LEFT = \"FROM_LEFT\";\nSlider.FROM_RIGHT = \"FROM_RIGHT\";","map":{"version":3,"sources":["/workspace/pp/src/Slider/index.jsx"],"names":["React","classNames","Slider","props","state","animating","position","CENTER","animatePrepare","startAnimation","bind","postPrepareAnimation","onTransitionEnd","node","addEventListener","removeEventListener","newProps","animationCallback","noAnimate","animatingOut","TO_LEFT","TO_RIGHT","includes","currentlyIn","FROM_LEFT","FROM_RIGHT","_animationCallback","setState","_postPrepareTimeout","setTimeout","clearTimeout","e","propertyName","callback","Boolean","className","children","Component"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport classNames from \"classnames\";\nimport \"./style.css\";\n\nexport default class Slider extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      animating: false,\n      position: Slider.CENTER,\n      animatePrepare: false\n    };\n\n    this.startAnimation = this.startAnimation.bind(this);\n    this.postPrepareAnimation = this.postPrepareAnimation.bind(this);\n    this.onTransitionEnd = this.onTransitionEnd.bind(this);\n  }\n\n  componentDidMount() {\n    this.startAnimation(this.props.position);\n    if (this.node) {\n      this.node.addEventListener(\"transitionend\", this.onTransitionEnd);\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.node) {\n      this.node.removeEventListener(\"transitionend\", this.onTransitionEnd);\n    }\n  }\n\n  componentWillReceiveProps(newProps) {\n    if (newProps.position !== this.props.position) {\n      this.startAnimation(newProps.position, newProps.animationCallback);\n    }\n  }\n\n  startAnimation(position, animationCallback) {\n    const noAnimate = position === Slider.CENTER;\n    const animatingOut = [Slider.TO_LEFT, Slider.TO_RIGHT].includes(position);\n    const currentlyIn = [\n      Slider.CENTER,\n      Slider.FROM_LEFT,\n      Slider.FROM_RIGHT\n    ].includes(this.state.position);\n    if (noAnimate || (currentlyIn && animatingOut)) {\n      // in these cases we don't need to prepare our animation at all, we can just\n      // run straight into it\n      this._animationCallback = animationCallback;\n      return this.setState({\n        animatePrepare: false,\n        position\n      });\n    }\n\n    this._animationCallback = this.postPrepareAnimation;\n    // in case the transition fails, we also post-prepare after some ms (whichever\n    // runs first should cancel the other)\n    this._postPrepareTimeout = setTimeout(this.postPrepareAnimation, 500);\n\n    this.setState({\n      animating: true,\n      animatePrepare: true,\n      position\n    });\n  }\n\n  postPrepareAnimation() {\n    clearTimeout(this._postPrepareTimeout);\n    this._animationCallback = null;\n\n    this.setState(\n      { animatePrepare: false },\n      () => (this._animationCallback = this.props.animationCallback)\n    );\n  }\n\n  onTransitionEnd(e) {\n    // the Slider transitions the `transform` property. Any other transitions\n    // that occur on the element we can just ignore.\n    if (e.propertyName !== \"transform\") return;\n\n    const callback = this._animationCallback;\n    delete this._animationCallback;\n\n    // an animation callback is another animation, so we only set `animating` to\n    // `false` when we finish the follow-up animation\n    if (callback) setTimeout(callback, 0);\n    else this.setState({ animating: false });\n  }\n\n  render() {\n    return (\n      <div\n        ref={node => (this.node = node)}\n        className={classNames(\"animatable\", {\n          [\"to\"]: [Slider.TO_LEFT, Slider.TO_RIGHT].includes(\n            this.state.position\n          ),\n          [\"from\"]: [Slider.FROM_LEFT, Slider.FROM_RIGHT].includes(\n            this.state.position\n          ),\n          [\"right\"]: [Slider.TO_RIGHT, Slider.FROM_RIGHT].includes(\n            this.state.position\n          ),\n          [\"left\"]: [Slider.TO_LEFT, Slider.FROM_LEFT].includes(\n            this.state.position\n          ),\n          [\"prepare\"]: this.state.animatePrepare\n        })}\n        data-qa-loading={Boolean(\n          this.props[\"data-qa-loading\"] || this.state.animating\n        )}\n      >\n        <div className={this.props.className}>{this.props.children}</div>\n      </div>\n    );\n  }\n}\n\nSlider.CENTER = \"CENTER\";\nSlider.TO_LEFT = \"TO_LEFT\";\nSlider.TO_RIGHT = \"TO_RIGHT\";\nSlider.FROM_LEFT = \"FROM_LEFT\";\nSlider.FROM_RIGHT = \"FROM_RIGHT\";\n"]},"metadata":{},"sourceType":"module"}